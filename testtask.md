# Задача 2
Для теста программ в задаче №2 использовалась виртуальная windows 10 191206-1406

## 2.1 Решение:
Действительно, существует моножество вариантов обойти UAC, например, второй вариант [отсюда](https://github.com/rootm0s/WinPwnage#uac-bypass-techniques)

для начала нужно скомпилировать проект, сделать это можно так
```bash
pip install pyinstaller
pyinstaller --onefile main.py
```

В каталоге dist нас будет ожидать exe файл

далее запускаем его:
```bash
main --use uac --id 2 --payload c:\\windows\\system32\\cmd.exe
```
В результате открывается cmd с правами администратора без UAC

![Alt text](poc2.1.gif)

## 2.2 Решение:

Скачиваем проект [отсюда](https://github.com/kernelm0de/ProcessHider).
1. Устанавливаем набор инструментов от 2015 года, чтобы собрать проект.![Alt text](image-1.png)
2. Перенести все файлы из include в папку ProcessHider и поправить импорты в main.cpp в той же папке
![Alt text](image-3.png)
3. Открываем проект и обновляем **target platform version до 10**.
![Alt text](image-2.png)

Cобираем проект и запускаем от имени администратора/


![Alt text](poc2.2.gif)

## 2.3 Решение:

Так как атакуемая машина может находиться за NAT, то можно использовать сервер с белым ip-адресом. В таком случае мы будем общаться с машиной жертвы через сервер-посредник.

Решением является сервер, и два клиента, оба клиента подключаются к серверу, так как у него инвестный белый ip, клиент жертвы просто запускает команды через `exec.Command()`, а клиент-нападающий их отправляет.

Код программы [githab]()

# Задача 3

## 3.0 Решение:

Решением является [go-код](). Список процессов получаем от системы вызывая `exec.Command("ps", "aux")`. Результат команды - сырой текст, его нужно дополнительно форматировать.

## 3.1 Решение:

Описываем dockerfile и собираем его, например такой командой, если находимся в корне проекта

```bash 
docker build -f build/package/dockerfile -t imageName .
```

Чтобы запустить контейнер нужно дополнительно указать **--pid="host"**, чтобы увидеть процессы хоста, а не контейнера.
Например, такой командой:

```bash 
docker run --pid="host" --rm -p 8080:8080 imageName
```

Теперь, если мы зайдем на http://127.0.0.1:8080/process, то сможем увидеть список процессов хоста:

![PoC](image.png)
